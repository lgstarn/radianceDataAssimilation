! fourth part minimization routine:lbfgs(liu and nocedal 1989)
      subroutine va15ad(n,m,x,f,g,diagco,diag,iprint,eps,s,y, &
                point,w,iflag)
       implicit real(8) (a-h), real(8) (o-z)

      integer :: n, m
      real(8) x,g,s,y,diag,w
      real(8) ftol,xtol,stpmin,stpmax,stp,f,ys,sq, &
                    yr,beta,one,zero,eps,xnorm,gnorm,yy,stp1
      integer bound,iter,nfun,nfev,iprint(2),point,cp,iflag
      dimension x(n),g(n),s(m*n),y(m*n),diag(n),w(n+2*m)
      logical finish,diagco

      integer :: i, ii, info, j, k, maxfev, npt

!      common /va15dd/mp,lp,gtol
      save
      data one,zero/1.0d+0,0.0d+0/
!     ------------------------------------------------------------
!     initialize
!     ------------------------------------------------------------
      if(iflag.eq.0) go to 1
      go to (72,10) iflag
   1  iter= 0
      if(n.le.0.or.m.le.0) then
          iflag= -8
          if(lp.gt.0) then
            write(lp,140)iflag
          end if
      end if
      print *,'Using gtol',gtol
      if(gtol.le.1.d-08) then
        if(lp.gt.0) write(lp,145)
        gtol=1.d-08
      endif
      nfun= 1
      point= 0
      finish= .false.
      if(diagco) then
         do i=1,n
            if (diag(i).le.zero) then
                iflag= -7
                if(lp.gt.0) write(lp,135)iflag,i
                return
            end if
         end do
      else
         do i=1,n
            diag(i)= 1.0d0
         end do
      endif
      do i=1,n
          s(i)= -g(i)*diag(i)
      end do
      gnorm= sqrt(ddot(n,g,1,g,1))
      stp1= one/gnorm
!     parameters for line search routine
!     ----------------------------------
      ftol= 1.0d-4
      xtol= 1.0d-17
      stpmin= 1.0d-20
      stpmax= 1.0d+20
      maxfev= 100
       call va15bd(iprint,iter,nfun, &
                           n,m,x,f,g,stp,finish)
!    ------------------------------------------------------------
!     main iteration loop
!    --------------------------------------------------------
 8    iter= iter+1
      info=0
      bound=iter-1
      if (iter .gt. m)bound=m
      if(iter.eq.1) go to 65
!     ------------------------------------------------------------
!     compute -hg and the diagonal scaling matrix in diag
!     ------------------------------------------------------------
      if(.not.diagco) then
         do i=1,n
            diag(i)= ys/yy
         end do
      else
         iflag=2
         return
      endif
  10  continue
      do i=1,n
         if (diag(i).le.zero) then
             iflag= -7
             if(lp.gt.0) write(lp,135)iflag,i
             return
         end if
      end do
      cp= point
      if (point.eq.0) cp=m
      w(n+cp)= one/ys
      do i=1,n
         w(i)= -g(i)
      end do
      cp= point
      do ii= 1,bound
         cp=cp-1
         if (cp.eq. -1)cp=m-1
         sq= ddot(n,s(cp*n+1),1,w,1)
         w(n+m+cp+1)= w(n+cp+1)*sq
         do k=1,n
            w(k)= w(k)-w(n+m+cp+1)*y(cp*n+k)
         end do
      end do
      do i=1,n
          w(i)=diag(i)*w(i)
      end do
      do ii=1,bound
         yr= ddot(n,y(cp*n+1),1,w,1)
         beta= w(n+cp+1)*yr
         do k=1,n
            w(k)= w(k)+s(cp*n+k)*(w(n+m+cp+1)-beta)
         end do
         cp=cp+1
         if (cp.eq.m)cp=0
      end do
!     ------------------------------------------------------------
!     store the new direction in s
!     ------------------------------------------------------------
       do j=1,n
          s(point*n+j)= w(j)
       end do
!     ------------------------------------------------------------
!     obtain the minimizer of the function along the
!     direction s by using the line search routine of vd05ad
!     ------------------------------------------------------------
  65  nfev=0
      stp=one
      if (iter.eq.1) stp=stp1
      do i=1,n
         w(i)=g(i)
      end do
  72  continue
      call vd05ad(n,x,f,g,s(point*n+1),stp,ftol,gtol, &
                  xtol,stpmin,stpmax,maxfev,info,nfev,diag)
      if (info .eq. -1) then
        iflag=1
        return
      endif
      if (info .ne. 1) go to 90
      nfun= nfun + nfev
!     ------------------------------------------------------------
!     compute the new s and y
!     ------------------------------------------------------------
      npt=point*n
      do i=1,n
          s(npt+i)= stp*s(npt+i)
          y(npt+i)= g(i)-w(i)
      end do
      ys= ddot(n,y(npt+1),1,s(npt+1),1)
      yy= ddot(n,y(npt+1),1,y(npt+1),1)
      point=point+1
      if (point.eq.m)point=0
!     ------------------------------------------------------------
!     convergence check
!     ------------------------------------------------------------
      gnorm= ddot(n,g,1,g,1)
      gnorm=sqrt(gnorm)
      xnorm= ddot(n,x,1,x,1)
      xnorm=sqrt(xnorm)
      xnorm= max(1.0d0,xnorm)
      if (gnorm/xnorm .le. eps) finish=.true.
      call va15bd(iprint,iter,nfun, &
                     n,m,x,f,g,stp,finish)
      if (finish) then
         iflag=0
         return
      endif
      go to 8
!     ------------------------------------------------------------
!     end of main iteration loop. error exits.
!     ------------------------------------------------------------
  90  if(lp.le.0) return
      if (info.eq.0) then
           iflag= -1
           write(lp,100)iflag
      else if (info.eq.2) then
           iflag= -2
           write(lp,105)iflag
      else if (info.eq.3) then
           iflag= -3
           write(lp,110)iflag
      else if (info.eq.4) then
           iflag= -4
           write(lp,115)iflag
      else if (info.eq.5) then
           iflag= -5
           write(lp,120)iflag
      else if (info.eq.6) then
           iflag= -6
           write(lp,125)iflag
      endif
      return
  95  iflag= -7
      if(lp.gt.0) write(lp,135)iflag,i
      return
  96  iflag= -8
      if(lp.gt.0) write(lp,140)iflag
!     ------------------------------------------------------------
!     formats
!     ------------------------------------------------------------
 100  format(/' iflag= ',i2,/' improper input parameters during', &
             ' the line search.')
 105  format(/' iflag= ',i2,/' relative width of the interval of', &
             ' uncertainty in the line search'/'is of the order of', &
                'machine roundoff.')
 110  format(/' iflag= ',i2,/' number of calls to function in the', &
             ' line search has reached 20.')
 115  format(/' iflag= ',i2,/' the step in the line search is', &
             ' too small.')
 120  format(/' iflag= ',i2,/' the step in the line search is', &
             ' too large.')
 125  format(/' iflag= ',i2,/' rounding errors prevent further', &
             ' progress in the line search.')
 135  format(/' iflag= ',i2,/' the',i5,'-th diagonal element of the', &
             ' inverse hessian approximation is not positive')
 140  format(/' iflag= ',i2,/' improper input parameters (n or m', &
             ' are not positive)')
 145  format(/'  gtol is less than or equal to 1.d-08', &
             / 'it has been reset to 1.d-08')
      return
      end
      subroutine va15bd(iprint,iter,nfun, &
                           n,m,x,f,g,stp,finish)
!     ---------------------------------------------------------------------
!     this routine prints monitoring information. the frequency and amount
!     of output are specified as follows:
!     iprint(1) < 0 : no output is generated
!     iprint(1) = 0 : output only at first and last iteration
!     iprint(1) > 0 : output every iprint(1) iteration
!     iprint(2) = 0 : iteration count, function value, norm of the gradient
!                     ,number of function calls and step length
!     iprint(2) = 1 : + vector of variables and gradient vector at the
!                       initial point
!     iprint(2) = 2 : + vector of variables
!     iprint(2) = 3 : + gradient vector
!     ---------------------------------------------------------------------
       implicit real(8) (a-h),real(8) (o-z)

      integer :: n, m
      real(8) x,g,f,gnorm,stp,factor,ddot,gzero
      dimension x(n),g(n)
      integer iprint(2),iter,nfun,prob
      logical finish
      integer :: i
      !common /set/ factor,prob
      ! common /va15dd/mp,lp, gtol
      if (iprint(1).lt.0)return
      gnorm= dot_product(g,g) !ddot(n,g,1,g,1)
      gnorm= sqrt(gnorm)
      gzero=1.d0
      if (iter.eq.0)then
           write(mp,10)
           write(mp,20) n,m
           write(mp,30)f,gnorm
                 if (iprint(2).ge.1)then
                     write(mp,40)
                     write(mp,50) (x(i),i=1,n)
                     write(mp,60)
                     write(mp,50) (g(i),i=1,n)
                  endif
           write(mp,10)
           write(mp,70)
      else
          if ((iprint(1).eq.0).and.(iter.ne.1.and..not.finish))return
              if (iprint(1).ne.0)then
                   if(mod(iter-1,iprint(1)).eq.0.or.finish)then
                         write(mp,80)iter,nfun,f,gnorm,stp
                         write(84,*) nfun,f,gnorm
                   else
                         return
                   endif
              else
                         write(mp,80)iter,nfun,f,gnorm,stp
                         write(84,*)nfun,f,gnorm
              endif
              if (iprint(2).eq.2.or.iprint(2).eq.3)then
                    if (finish)then
                        write(mp,90)
                    else
                        write(mp,40)
                    endif
                      write(mp,50)(x(i),i=1,n)
                  if (iprint(2).eq.3)then
                      write(mp,60)
                      write(mp,50)(g(i),i=1,n)
                  endif
              endif
            if (finish) write(mp,100)
      endif
 10   format('*************************************************')
 20   format('        n=',i5,'   number of corrections=',i2)
 30   format(' f= ',1pd10.3,'   gnorm= ',1pd10.3)
 40   format(' vector x= ')
 50   format(6(2x,1pd10.3))
 60   format(' gradient vector g= ')
 70   format(/'   i   nfn',4x,'func',8x,'gnorm',7x,'steplength'/)
 80   format(2(i4,1x),3x,3(1pd10.3,2x))
 90   format(' final point x= ')
 100  format(/' the minimization terminated without detecting errors.', &
             /' iflag = 0')
      return
      end
!   ----------------------------------------------------------
!   data block
!   ----------------------------------------------------------
!      block data va15cd
!      common /va15dd/mp,lp, gtol
!      integer lp,mp
!      real(8) gtol
!      data mp,lp,gtol/6,6,3.0d-01/
!      end
!   -------------------------------------------------------------
      subroutine vd05ad(n,x,f,g,s,stp,ftol,gtol,xtol, &
                        stpmin,stpmax,maxfev,info,nfev,wa)
      implicit real(8) (a-h), real(8) (o-z)

      integer n,maxfev,info,nfev
      real(8) f,stp,ftol,gtol,xtol,stpmin,stpmax
      real(8) x,g,s,wa
      dimension x(n),g(n),s(n),wa(n)
      save

!     **********
!     subroutine vd05ad
!     the purpose of vd05ad is to find a step which satisfies
!     a sufficient decrease condition and a curvature condition.
!     the user must provide a subroutine which calculates the
!     function and the gradient.
!     at each stage the subroutine updates an interval of
!     uncertainty with endpoints stx and sty. the interval of
!     uncertainty is initially chosen so that it contains a
!     minimizer of the modified function
!          f(x+stp*s) - f(x) - ftol*stp*(gradf(x)'s).
!     if a step is obtained for which the modified function
!     has a nonpositive function value and nonnegative derivative,
!     then the interval of uncertainty is chosen so that it
!     contains a minimizer of f(x+stp*s).
!     the algorithm is designed to find a step which satisfies
!     the sufficient decrease condition
!           f(x+stp*s) .le. f(x) + ftol*stp*(gradf(x)'s),
!     and the curvature condition
!           abs(gradf(x+stp*s)'s)) .le. gtol*abs(gradf(x)'s).
!     if ftol is less than gtol and if, for example, the function
!     is bounded below, then there is always a step which satisfies
!     both conditions. if no step can be found which satisfies both
!     conditions, then the algorithm usually stops when rounding
!     errors prevent further progress. in this case stp only
!     satisfies the sufficient decrease condition.
!     the subroutine statement is
!        subroutine vd05ad(n,x,f,g,s,stp,ftol,gtol,xtol,
!                          stpmin,stpmax,maxfev,info,nfev,wa)
!     where
!       n is a positive integer input variable set to the number
!         of variables.
!       x is an array of length n. on input it must contain the
!         base point for the line search. on output it contains
!         x + stp*s.
!       f is a variable. on input it must contain the value of f
!         at x. on output it contains the value of f at x + stp*s.
!       g is an array of length n. on input it must contain the
!         gradient of f at x. on output it contains the gradient
!         of f at x + stp*s.
!       s is an input array of length n which specifies the
!         search direction.
!       stp is a nonnegative variable. on input stp contains an
!         initial estimate of a satisfactory step. on output
!         stp contains the final estimate.
!       ftol and gtol are nonnegative input variables. termination
!         occurs when the sufficient decrease condition and the
!         directional derivative condition are satisfied.
!       xtol is a nonnegative input variable. termination occurs
!         when the relative width of the interval of uncertainty
!         is at most xtol.
!       stpmin and stpmax are nonnegative input variables which
!         specify lower and upper bounds for the step.
!       maxfev is a positive integer input variable. termination
!         occurs when the number of calls to fcn is at least
!         maxfev by the end of an iteration.
!       info is an integer output variable set as follows:
!         info = 0  improper input parameters.
!         info =-1  a return is made to compute the function and gradient.
!         info = 1  the sufficient decrease condition and the
!                   directional derivative condition hold.
!         info = 2  relative width of the interval of uncertainty
!                   is at most xtol.
!         info = 3  number of calls to fcn has reached maxfev.
!         info = 4  the step is at the lower bound stpmin.
!         info = 5  the step is at the upper bound stpmax.
!         info = 6  rounding errors prevent further progress.
!                   there may not be a step which satisfies the
!                   sufficient decrease and curvature conditions.
!                   tolerances may be too small.
!       nfev is an integer output variable set to the number of
!         calls to fcn.
!       wa is a work array of length n.
!     subprograms called
!       harwell-supplied...vd05bd
!       fortran-supplied...abs,max,min
!     argonne national laboratory. minpack project. june 1983
!     jorge j. more', david j. thuente
!     **********
      integer infoc,j
      logical brackt,stage1
      real(8) dg,dgm,dginit,dgtest,dgx,dgxm,dgy,dgym, &
             finit,ftest1,fm,fx,fxm,fy,fym,p5,p66,stx,sty, &
             stmin,stmax,width,width1,xtrapf,zero
      data p5,p66,xtrapf,zero /0.5d0,0.66d0,4.0d0,0.0d0/
      if(info.eq.-1) go to 45
      infoc = 1
!     check the input parameters for errors.
      if (n .le. 0 .or. stp .le. zero .or. ftol .lt. zero .or. &
          gtol .lt. zero .or. xtol .lt. zero .or. stpmin .lt. zero &
          .or. stpmax .lt. stpmin .or. maxfev .le. 0) return
!     compute the initial gradient in the search direction
!     and check that s is a descent direction.
      dginit = zero
      do 10 j = 1, n
         dginit = dginit + g(j)*s(j)
   10    continue
      if (dginit .ge. zero) return
!     initialize local variables.
      brackt = .false.
      stage1 = .true.
      nfev = 0
      finit = f
      dgtest = ftol*dginit
      width = stpmax - stpmin
      width1 = width/p5
      do 20 j = 1, n
         wa(j) = x(j)
   20    continue
!     the variables stx, fx, dgx contain the values of the step,
!     function, and directional derivative at the best step.
!     the variables sty, fy, dgy contain the value of the step,
!     function, and derivative at the other endpoint of
!     the interval of uncertainty.
!     the variables stp, f, dg contain the values of the step,
!     function, and derivative at the current step.
      stx = zero
      fx = finit
      dgx = dginit
      sty = zero
      fy = finit
      dgy = dginit
!     start of iteration.
   30 continue
!        set the minimum and maximum steps to correspond
!        to the present interval of uncertainty.
         if (brackt) then
            stmin = min(stx,sty)
            stmax = max(stx,sty)
         else
            stmin = stx
            stmax = stp + xtrapf*(stp - stx)
            end if
!        force the step to be within the bounds stpmax and stpmin.
         stp = max(stp,stpmin)
         stp = min(stp,stpmax)
!        if an unusual termination is to occur then let
!        stp be the lowest point obtained so far.
         if ((brackt .and. (stp .le. stmin .or. stp .ge. stmax)) &
            .or. nfev .ge. maxfev-1 .or. infoc .eq. 0 &
            .or. (brackt .and. stmax-stmin .le. xtol*stmax)) stp = stx
!        evaluate the function and gradient at stp
!        and compute the directional derivative.
         do 40 j = 1, n
            x(j) = wa(j) + stp*s(j)
   40       continue
         info=-1
         return
   45    info=0
         nfev = nfev + 1
         dg = zero
         do 50 j = 1, n
            dg = dg + g(j)*s(j)
   50       continue
         ftest1 = finit + stp*dgtest
!        test for convergence.
         if ((brackt .and. (stp .le. stmin .or. stp .ge. stmax)) &
            .or. infoc .eq. 0) info = 6
         if (stp .eq. stpmax .and. &
             f .le. ftest1 .and. dg .le. dgtest) info = 5
         if (stp .eq. stpmin .and. &
             (f .gt. ftest1 .or. dg .ge. dgtest)) info = 4
         if (nfev .ge. maxfev) info = 3
         if (brackt .and. stmax-stmin .le. xtol*stmax) info = 2
         if (f .le. ftest1 .and. abs(dg) .le. gtol*(-dginit)) info = 1
!        check for termination.
         if (info .ne. 0) return
!        in the first stage we seek a step for which the modified
!        function has a nonpositive value and nonnegative derivative.
         if (stage1 .and. f .le. ftest1 .and. &
             dg .ge. min(ftol,gtol)*dginit) stage1 = .false.
!        a modified function is used to predict the step only if
!        we have not obtained a step for which the modified
!        function has a nonpositive function value and nonnegative
!        derivative, and if a lower function value has been
!        obtained but the decrease is not sufficient.
         if (stage1 .and. f .le. fx .and. f .gt. ftest1) then
!           define the modified function and derivative values.
            fm = f - stp*dgtest
            fxm = fx - stx*dgtest
            fym = fy - sty*dgtest
            dgm = dg - dgtest
            dgxm = dgx - dgtest
            dgym = dgy - dgtest
!           call cstep to update the interval of uncertainty
!           and to compute the new step.
            call vd05bd(stx,fxm,dgxm,sty,fym,dgym,stp,fm,dgm, &
                       brackt,stmin,stmax,infoc)
!           reset the function and gradient values for f.
            fx = fxm + stx*dgtest
            fy = fym + sty*dgtest
            dgx = dgxm + dgtest
            dgy = dgym + dgtest
         else
!           call vd05bd to update the interval of uncertainty
!           and to compute the new step.
            call vd05bd(stx,fx,dgx,sty,fy,dgy,stp,f,dg, &
                       brackt,stmin,stmax,infoc)
            end if
!        force a sufficient decrease in the size of the
!        interval of uncertainty.
         if (brackt) then
            if (abs(sty-stx) .ge. p66*width1) &
               stp = stx + p5*(sty - stx)
            width1 = width
            width = abs(sty-stx)
            end if
!        end of iteration.
         go to 30
!     last card of subroutine vd05ad.
      end
      subroutine vd05bd(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt, &
                       stpmin,stpmax,info)
       implicit real(8) (a-h),real(8) (o-z)

      integer info
      real(8) stx,fx,dx,sty,fy,dy,stp,fp,dp,stpmin,stpmax
      logical brackt,bound
!     **********
!     subroutine vd05bd
!     the purpose of vd05bd is to compute a safeguarded step for
!     a linesearch and to update an interval of uncertainty for
!     a minimizer of the function.
!     the parameter stx contains the step with the least function
!     value. the parameter stp contains the current step. it is
!     assumed that the derivative at stx is negative in the
!     direction of the step. if brackt is set true then a
!     minimizer has been bracketed in an interval of uncertainty
!     with endpoints stx and sty.
!     the subroutine statement is
!       subroutine vd05bd(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,
!                        stpmin,stpmax,info)
!     where
!       stx, fx, and dx are variables which specify the step,
!         the function, and the derivative at the best step obtained
!         so far. the derivative must be negative in the direction
!         of the step, that is, dx and stp-stx must have opposite
!         signs. on output these parameters are updated appropriately.
!       sty, fy, and dy are variables which specify the step,
!         the function, and the derivative at the other endpoint of
!         the interval of uncertainty. on output these parameters are
!         updated appropriately.
!       stp, fp, and dp are variables which specify the step,
!         the function, and the derivative at the current step.
!         if brackt is set true then on input stp must be
!         between stx and sty. on output stp is set to the new step.
!       brackt is a logical variable which specifies if a minimizer
!         has been bracketed. if the minimizer has not been bracketed
!         then on input brackt must be set false. if the minimizer
!         is bracketed then on output brackt is set true.
!       stpmin and stpmax are input variables which specify lower
!         and upper bounds for the step.
!       info is an integer output variable set as follows:
!         if info = 1,2,3,4,5, then the step has been computed
!         according to one of the five cases below. otherwise
!         info = 0, and this indicates improper input parameters.
!     subprograms called
!       fortran-supplied ... abs,max,min,sqrt
!     argonne national laboratory. minpack project. june 1983
!     jorge j. more', david j. thuente
!     **********
      real(8) gamma,p,q,r,s,sgnd,stpc,stpf,stpq,theta
      info = 0
!     check the input parameters for errors.
      if ((brackt .and. (stp .le. min(stx,sty) .or. &
          stp .ge. max(stx,sty))) .or. &
          dx*(stp-stx) .ge. 0.0 .or. stpmax .lt. stpmin) return
!     determine if the derivatives have opposite sign.
      sgnd = dp*(dx/abs(dx))
!     first case. a higher function value.
!     the minimum is bracketed. if the cubic step is closer
!     to stx than the quadratic step, the cubic step is taken,
!     else the average of the cubic and quadratic steps is taken.
      if (fp .gt. fx) then
         info = 1
         bound = .true.
         theta = 3*(fx - fp)/(stp - stx) + dx + dp
         s = max(abs(theta),abs(dx),abs(dp))
         gamma = s*sqrt((theta/s)**2 - (dx/s)*(dp/s))
         if (stp .lt. stx) gamma = -gamma
         p = (gamma - dx) + theta
         q = ((gamma - dx) + gamma) + dp
         r = p/q
         stpc = stx + r*(stp - stx)
         stpq = stx + ((dx/((fx-fp)/(stp-stx)+dx))/2)*(stp - stx)
         if (abs(stpc-stx) .lt. abs(stpq-stx)) then
            stpf = stpc
         else
           stpf = stpc + (stpq - stpc)/2
           end if
         brackt = .true.
!     second case. a lower function value and derivatives of
!     opposite sign. the minimum is bracketed. if the cubic
!     step is closer to stx than the quadratic (secant) step,
!     the cubic step is taken, else the quadratic step is taken.
      else if (sgnd .lt. 0.0) then
         info = 2
         bound = .false.
         theta = 3*(fx - fp)/(stp - stx) + dx + dp
         s = max(abs(theta),abs(dx),abs(dp))
         gamma = s*sqrt((theta/s)**2 - (dx/s)*(dp/s))
         if (stp .gt. stx) gamma = -gamma
         p = (gamma - dp) + theta
         q = ((gamma - dp) + gamma) + dx
         r = p/q
         stpc = stp + r*(stx - stp)
         stpq = stp + (dp/(dp-dx))*(stx - stp)
         if (abs(stpc-stp) .gt. abs(stpq-stp)) then
            stpf = stpc
         else
            stpf = stpq
            end if
         brackt = .true.
!     third case. a lower function value, derivatives of the
!     same sign, and the magnitude of the derivative decreases.
!     the cubic step is only used if the cubic tends to infinity
!     in the direction of the step or if the minimum of the cubic
!     is beyond stp. otherwise the cubic step is defined to be
!     either stpmin or stpmax. the quadratic (secant) step is also
!     computed and if the minimum is bracketed then the the step
!     closest to stx is taken, else the step farthest away is taken.
      else if (abs(dp) .lt. abs(dx)) then
         info = 3
         bound = .true.
         theta = 3*(fx - fp)/(stp - stx) + dx + dp
         s = max(abs(theta),abs(dx),abs(dp))
!        the case gamma = 0 only arises if the cubic does not tend
!        to infinity in the direction of the step.
         gamma = s*sqrt(max(0.0d0,(theta/s)**2 - (dx/s)*(dp/s)))
         if (stp .gt. stx) gamma = -gamma
         p = (gamma - dp) + theta
         q = (gamma + (dx - dp)) + gamma
         r = p/q
         if (r .lt. 0.0 .and. gamma .ne. 0.0) then
            stpc = stp + r*(stx - stp)
         else if (stp .gt. stx) then
            stpc = stpmax
         else
            stpc = stpmin
            end if
         stpq = stp + (dp/(dp-dx))*(stx - stp)
         if (brackt) then
            if (abs(stp-stpc) .lt. abs(stp-stpq)) then
               stpf = stpc
            else
               stpf = stpq
               end if
         else
            if (abs(stp-stpc) .gt. abs(stp-stpq)) then
               stpf = stpc
            else
               stpf = stpq
               end if
            end if
!     fourth case. a lower function value, derivatives of the
!     same sign, and the magnitude of the derivative does
!     not decrease. if the minimum is not bracketed, the step
!     is either stpmin or stpmax, else the cubic step is taken.
      else
         info = 4
         bound = .false.
         if (brackt) then
            theta = 3*(fp - fy)/(sty - stp) + dy + dp
            s = max(abs(theta),abs(dy),abs(dp))
            gamma = s*sqrt((theta/s)**2 - (dy/s)*(dp/s))
            if (stp .gt. sty) gamma = -gamma
            p = (gamma - dp) + theta
            q = ((gamma - dp) + gamma) + dy
            r = p/q
            stpc = stp + r*(sty - stp)
            stpf = stpc
         else if (stp .gt. stx) then
            stpf = stpmax
         else
            stpf = stpmin
            end if
         end if
!     update the interval of uncertainty. this update does not
!     depend on the new step or the case analysis above.
      if (fp .gt. fx) then
         sty = stp
         fy = fp
         dy = dp
      else
         if (sgnd .lt. 0.0) then
            sty = stx
            fy = fx
            dy = dx
            end if
         stx = stp
         fx = fp
         dx = dp
         end if
!     compute the new step and safeguard it.
      stpf = min(stpmax,stpf)
      stpf = max(stpmin,stpf)
      stp = stpf
      if (brackt .and. bound) then
         if (sty .gt. stx) then
            stp = min(stx+0.66*(sty-stx),stp)
         else
            stp = max(stx+0.66*(sty-stx),stp)
            end if
         end if
      return
!     last card of subroutine vd05bd.
      end

!       real(8) function ddott(n,d,i1,s,i2)

!      -------------------------------------------------------
!      this function computes the inner product of two vectors
!      -------------------------------------------------------
!       real(8) d(n),s(n),prod
!       integer i1,i2
!        prod=0.0d0
!        do 10 i=1,n
! 10     prod= prod+d(i)*s(i)
!        ddot= prod
!       return
!       end
      double precision function ddot(ndim,ta,i1,tb,i2)

!      implicit real(8) (a-h),real(8) (o-z)
	  implicit none
      integer :: ndim
      real(8), dimension(:) :: ta(ndim),tb(ndim)
!      parameter (m =ndim,nt = 80,
!     %  nm1= ndim-1,mm1= m-1,nm2= nm1-1,mm2= mm1-1,
!     %  nctr= 3*nm2*mm2, ntrav=25*nctr)
      real(8) dzs(3),aps,bps,cps,ps
      integer i1,i2
      ddot=dot_product(ta,tb)
      return
      end
