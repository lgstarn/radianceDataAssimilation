!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
! 
!     LMBM includes the following subroutines
!
!     S   LMBMU         Initialization for limited memory bundle
!                         subroutine.
!     S   LMBM          Limited memory bundle subroutine for nonsmooth
!                         large-scale optimization.
!
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!     * SUBROUTINE LMBMU *
!
!
!     * Purpose *
!
!     Initialization for limited memory bundle subroutine for
!     large-scale unconstrained nonsmooth optimization.
!
!
!     * Calling sequence *
!
!     CALL LMBMU(N,NA,MCU,MC,NW,X,F,RPAR,IPAR,IOUT,TIME,RTIM,W)
!
!
!     * Parameters *
!
!     II  N             Number of variables.
!     II  NA            Maximum bundle dimension, NA >= 2.
!     IU  MC            Maximum number of stored corrections, MC >= 3.
!     II  MCU           Upper limit for maximum number of stored
!                         corrections, MCU >= MC.
!     RU  X(N)          Vector of variables.
!     RO  F             Value of the objective function.
!     RI  TIME          Maximum CPU-time in seconds. If TIME <= 0.0
!                         the maximum time is ignored. REAL argument.
!     RI  RTIM(2)       Auxiliary array. REAL array
!                         On output RTIM(1) contains the execution time.
!     RI  RPAR(8)       Real parameters:
!           RPAR(1)       Tolerance for change of function values.
!           RPAR(2)       Second Tolerance for change of function values.
!           RPAR(3)       Tolerance for the function value.
!           RPAR(4)       Tolerance for the first termination criterion.
!           RPAR(5)       Tolerance for the second termination criterion.
!           RPAR(6)       Distance measure parameter, 0 <= RPAR(6).
!           RPAR(7)       Line search parameter, 0 < RPAR(7) < 0.25.
!           RPAR(8)       Maximum stepsize, 1 < RPAR(8).
!                           If RPAR(I) <= 0 for I=1,3,4,5,7, and 8 the
!                           default value of the parameter will be used.
!                           If RPAR(2) < 0 the the parameter and the
!                           corresponding termination criterion will be
!                           ignored. If RPAR(2) = 0 default value will
!                           be used. If RPAR(6) < 0 the default value
!                           will be used.
!     II  IPAR(7)       Integer paremeters:
!           IPAR(1)       Exponent for distance measure.
!           IPAR(2)       Maximum number of iterations.
!           IPAR(3)       Maximum number of function evaluations.
!           IPAR(4)       Maximum number of iterations with changes of
!                           function values smaller than RPAR(1).
!           IPAR(5)       Printout specification:
!                             -1  - No printout.
!                              0  - Only the error messages.
!                              1  - The final values of the objective
!                                   function.
!                              2  - The final values of the objective
!                                   function and the most serious
!                                   warning messages.
!                              3  - The whole final solution.
!                              4  - At each iteration values of the
!                                   objective function.
!                              5  - At each iteration the whole
!                                   solution
!           IPAR(6)       Selection of the method:
!                              0  - Limited memory bundle method.
!                              1  - L-BFGS bundle method.
!           IPAR(7)       Selection of the scaling:
!                              0  - Scaling at every iteration with STU/UTU.
!                              1  - Scaling at every iteration with STS/STU.
!                              2  - Interval scaling with STU/UTU.
!                              3  - Interval scaling with STS/STU.
!                              4  - Preliminary scaling with STU/UTU.
!                              5  - Preliminary scaling with STS/STU.
!                              6  - No scaling.
!     IO  IOUT(3)       Integer parameters:
!           IOUT(1)       Number of used iterations.
!           IOUT(2)       Number of used function evaluations.
!           IOUT(3)       Cause of termination:
!                              1  - The problem has been solved.
!                                   with desired accuracy.
!                              2  - Changes in function values < RPAR(1)
!                                   in IPAR(4) subsequent iterations.
!                              3  - Changes in function values < RPAR(2)
!                                   *SMALL*MAX(|F_k|,|F_k+1|,1), where
!                                   SMALL is the smallest positive
!                                   number such that 1.0 + SMALL > 1.0.
!                              4  - Number of function calls > IPAR(3).
!                              5  - Number of iterations > IPAR(2).
!                              6  - Time limit exceeded.
!                              7  - F < RPAR(3).
!                             -1  - Two consecutive restarts or number
!                                   of restarts > maximum number of
!                                   restarts.
!                             -2  - TMAX < TMIN in two subsequent
!                                   iterations.
!                             -3  - Failure in function or subgradient
!                                   calculations (assigned by the user).
!                             -4  - Failure in attaining the demanded
!                                   accuracy.
!                             -5  - Invalid input parameters.
!                             -6  - Not enough working space.
!     RA  W(NW)         Work vector.
!     II  NW            Dimension of the work vector W:
!                         NW >= 1 + 9*N + 2*N*NA + 3*NA + 2*N*(MCU+1)
!                               + 3*(MCU+2)*(MCU+1)/2 + 9*(MCU+1)
!
!
!     * Subprograms used *
!
!     S   LMBM         Limited memory bundle method for nonsmooth
!                        optimization.
!     S   WPRINT       Printout the error and warning messages.
!     S   GETIME       Execution time.
!
!
!
!     Napsu Karmitsa (2002 - 2004, last modified 2007)
!

      subroutine LMBMU(n,na,mcu,mc,nw,x,f,rpar,ipar,iout,time,rtim,w,funder_ptr)

!     Scalar Arguments
      integer n,na,mc,mcu,nw
      double precision f

!     Array Arguments
      integer ipar(*),iout(*)
      double precision x(*),rpar(*),w(*)

      procedure (funder_func), pointer :: funder_ptr

!     Local Scalars
      integer lxo,ls,lg,lgp,lga,lu,ld,lax,lag,laf,lsm,lum,lrm,lumtum,&
           lc,lsmtgp,lumtgp,ltmc1,ltmc2,ltmc3,ltmc4,ltmc5,ltmc6,ltn1,&
           ltn2,ltmat

!     External Subroutines
!      EXTERNAL LMBM,WPRINT,GETIME

!     CPU-time
      real time,start,fini
      real rtim(2)

!
!     CPU-time
!
      call GETIME(start,rtim)


!
!     Initialization and error checking
!

      iout(3) = 0

      if (n .le. 0) then
         iout(3) = -5
         call WPRINT(IOUT(3),IPAR(5),1)
         return
      end if


      if (mcu .lt. 3) then
         iout(3) = -5
         call WPRINT(IOUT(3),IPAR(5),2)
         return
      end if


      if (na .lt. 2) then
         iout(3) = -5
         call WPRINT(IOUT(3),IPAR(5),3)
         return
      end if


      if (RPAR(7) .ge. 0.25D+00) then
         iout(3) = -5
         call WPRINT(IOUT(3),IPAR(5),4)
         return
      end if


      if (nw .lt. 1 + 9*n + 2*n*na + 3*na + 2*n*(mcu+1) + &
           3*(mcu+2)*(mcu+1)/2 + 9*(mcu+1)) then
         iout(3) = -6
         call WPRINT(IOUT(3),IPAR(5),0)
         return
      end if


      if (IPAR(6) .gt. 1 .or. IPAR(6) .lt. 0) ipar(6) = 0
      if (IPAR(7) .gt. 6 .or. IPAR(7) .lt. 0) ipar(7) = 2


      if (mc .gt. mcu) then
         mc = mcu
         call WPRINT(IOUT(3),IPAR(5),-1)
      end if

      if (mc .le. 0) mc = 3


!
!     Pointers for working array W
!

      lxo    = 1
      ls     = lxo    + n
      lg     = ls     + n
      lgp    = lg     + n
      lga    = lgp    + n
      lu     = lga    + n
      ld     = lu     + n
      lax    = ld     + n
      lag    = lax    + n*na
      laf    = lag    + n*na
      lsm    = laf    + 3*na
      lum    = lsm    + n*(mcu+1)
      lrm    = lum    + n*(mcu+1)
      lumtum = lrm    + (mcu+2)*(mcu+1)/2
      lc     = lumtum + (mcu+2)*(mcu+1)/2
      lsmtgp = lc     + mcu+1
      lumtgp = lsmtgp + mcu+1
      ltmc1  = lumtgp + mcu+1
      ltmc2  = ltmc1  + mcu+1
      ltmc3  = ltmc2  + mcu+1
      ltmc4  = ltmc3  + mcu+1
      ltmc5  = ltmc4  + mcu+1
      ltmc6  = ltmc5  + mcu+1
      ltn1   = ltmc6  + mcu+1
      ltn2   = ltn1   + n
      ltmat  = ltn2   + n


!
!     Solution
!

      call LMBM(n,na,mc,mcu,x,W(lxo),W(ls),W(lg),W(lgp),W(lga),W(lu),&
           W(ld),f,W(lax),W(lag),W(laf),W(lsm),W(lum),W(lrm),W(lumtum),&
           W(lc),W(lsmtgp),W(lumtgp),W(ltmc1),W(ltmc2),W(ltmc3),W(ltmc4),&
           W(ltmc5),W(ltmc6),W(ltn1),W(ltn2),W(ltmat),RPAR(1),RPAR(2),&
           RPAR(3),RPAR(4),RPAR(5),RPAR(6),RPAR(7),RPAR(8),IPAR(2),&
           IPAR(3),IPAR(1),IPAR(4),IPAR(5),IPAR(6),IPAR(7),IOUT(1),&
           IOUT(2),IOUT(3),time,rtim,funder_ptr)


!
!     CPU-time
!

      call GETIME(fini,rtim)
      rtim(1) = fini - start

      return
      end subroutine



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!     * SUBROUTINE LMBM *
!
!
!     * Purpose *
!
!     Limited memory bundle subroutine for nonsmooth optimization.
!
!
!     * Calling sequence *
!
!     CALL LMBM(N,NA,MC,MCU,X,XO,S,G,GP,GA,U,D,F,AX,AG,AF,SM,UM,RM,
!    &     UMTUM,C,SMTGP,UMTGP,TMPMC1,TMPMC2,TMPMC3,TMPMC4,TMPMC5,
!    &     TMPMC6,TMPN1,TMPN2,TMPMAT,TOLF,TOLB,TOLG,TOLG2,ETA,EPSL,
!    &     XMAX,MIT,MFE,MOS,MTESF,IPRINT,METHOD,ISCALE,NIT,NFE,ITERM,
!    &     TIME,RTIM)
!
!
!     * Parameters *
!
!     II  N               Number of variables.
!     II  NA              Maximum bundle dimension.
!     IU  MC              Maximum number of stored corrections.
!     II  MCU             Upper limit for maximum number of stored
!                           corrections, MCU >= MC.
!     RU  X(N)            Vector of variables.
!     RA  XO(N)           Previous vector of variables.
!     RA  G(N)            Subgradient of the objective function.
!     RA  GP(N)           Previous subgradient of the objective function.
!     RA  GA(N)           Aggregate subgradient.
!     RA  S(N)            Difference of current and previous variables.
!     RA  U(N)            Difference of current and previous
!                           subgradients.
!     RA  D(N)            Search direction.
!     RO  F               Value of the objective function.
!     RA  AX(N*NA)        Matrix whose columns are bundle points.
!     RA  AG(N*NA)        Matrix whose columns are bundle subgradients.
!     RA  AF(3*NA)        Vector of bundle values.
!     RA  SM(N*(MC+1))    Matrix whose columns are stored differences of
!                           variables.
!     RA  UM(N*(MC+1))    Matrix whose columns are stored subgradient
!                           differences.
!     RA  RM((MC+2)*(MC+1)/2)  Upper triangular matrix stored columnwise
!                                in the one-dimensional array.
!     RU  UMTUM((MC+2)*(MC+1)/2)  Auxiliary matrix: TRANS(UM)*UM.
!     RU  C(MC+1)         Diagonal matrix.
!     RU  SMTGP(MC+1)     Auxiliary vector.
!     RU  UMTGP(MC+1)     Auxiliary vector.
!     RA  TMPMC#(MC+1)    Auxiliary arrays; # = 1,...,6.
!     RA  TMPN#(N)        Auxiliary arrays; # = 1,2.
!     RA  TMPMAT((MC+1)*(MC)/2)   Auxiliary matrix.
!     RI  TIME            Maximum CPU-time in seconds. If TIME <= 0.0
!                           the maximum time is ignored. REAL argument.
!     RI  RTIM(2)         Auxiliary array. REAL array.
!                           On input RTIM(1) contains the starting time.
!     RI  TOLF            Tolerance for change of function values.
!     RI  TOLF2           Second tolerance for change of function
!                           values.
!     RI  TOLB            Tolerance for the function value.
!     RI  TOLG            Tolerance for the first termination criterion.
!     RI  TOLG2           Tolerance for the second termination criterion.
!     RI  ETA             Distance measure parameter, ETA >= 0.
!     RI  EPSL            Line search parameter, 0 < EPSL < 0.25.
!     RI  XMAX            Maximum stepsize, 1 < XMAX.
!     II  MIT             Maximun number of iterations.
!     II  MFE             Maximun number of function evaluations.
!     II  MOS             Exponent for distance measure.
!     II  MTESF           Maximum number of iterations with changes of
!                           function values smaller than TOLF.
!     II  IPRINT          Printout specification:
!                            -1  - No printout.
!                             0  - Only the error messages.
!                             1  - The final values of the objective
!                                  function.
!                             2  - The final values of the objective
!                                  function and the most serious
!                                  warning messages.
!                             3  - The whole final solution.
!                             4  - At each iteration values of the
!                                  objective function.
!                             5  - At each iteration the whole
!                                  solution
!     II  METHOD          Selection of the method:
!                             0  - Limited memory bundle method.
!                             1  - L-BFGS bundle method.
!     II  ISCALE          Selection of the scaling:
!                             0  - Scaling at every iteration
!                                  with STU/UTU.
!                             1  - Scaling at every iteration
!                                  with STS/STU.
!                             2  - Interval scaling with STU/UTU.
!                             3  - Interval scaling with STS/STU.
!                             4  - Preliminary scaling with STU/UTU.
!                             5  - Preliminary scaling with STS/STU.
!                             6  - No scaling.
!     IO  NIT             Number of used iterations.
!     IO  NFE             Number of used function evaluations.
!     IO  ITERM           Cause of termination:
!                             1  - The problem has been solved.
!                                  with desired accuracy.
!                             2  - (F - FO) < TOLF in MTESF
!                                  subsequent iterations.
!                             3  - (F - FO) < TOLF*SMALL*MAX(|F|,|FO|,1).
!                             4  - Number of function calls > MFE.
!                             5  - Number of iterations > MIT.
!                             6  - Time limit exceeded.
!                             7  - F < TOLB.
!                            -1  - Two consecutive restarts.
!                            -2  - Number of restarts > maximum number
!                                  of restarts.
!                            -3  - Failure in function or subgradient
!                                  calculations (assigned by the user).
!                            -4  - Failure in attaining the demanded
!                                  accuracy.
!                            -5  - Invalid input parameters.
!                            -6  - Not enough working space.
!
!
!     * Local parameters *
!
!     I   MAXEPS          Maximum number of consecutive equal stopping
!                           criterions.
!     I   MAXNRS          Maximum number of restarts.
!     R   ETA9            Maximum for real numbers.
!     R   FMIN            Smallest acceptable value of the function.
!     R   TMIN            Minimum stepsize.
!     R   LENGTHD         Direction vector length.
!     R   RHO             Correction parameter.
!
!
!     * Local variables *
!
!     I   INEW            Index for the circular arrays.
!     I   IBUN            Index for the circular arrays in bundle.
!     I   IBFGS           Index of the type of BFGS update.
!     I   ISR1            Index of the type of SR1 update.
!     I   ITERS           Null step indicator.
!                              0  - Null step.
!                              1  - Serious step.
!     I   IC              Correction indicator.
!     I   ICN             Correction indicator for null steps.
!     I   IFLAG           Index for adaptive version:
!                              0  - Maximum number of stored corrections
!                                     has not been changed.
!                              1  - Maximum number of stored corrections
!                                     has been changed.
!     I   NAC             Current size of the bundle.
!     I   MCC             Current number of stored corrections.
!     I   MCINIT          Initial maximum number of stored corrections.
!     I   NEPS            Number of consecutive equal stopping
!                           criterions.
!     I   NNK             Consecutive null steps counter.
!     I   NRES            Number of consecutive restarts.
!     I   NRESS           Number of consecutive restarts in case of
!                           TMAX<TMIN.
!     I   NCRES           Number of restars.
!     I   NTESF           Number of tests on function decrease.
!     R   ALFN            Locality measure.
!     R   ALFV            Aggregate locality measure.
!     R   EPSR            Line search parameter.
!     R   GAMMA           Scaling parameter.
!     R   P               Directional derivative.
!     R   FO              Previous value of objective function.
!     R   DNORM           Euclidean norm of the direction vector.
!     R   GNORM           Euclidean norm of the aggregate subgradient
!                           vector.
!     R   XNORM           Stopping criterion.
!     R   PXNORM          Previous stopping criterion.
!     R   T               Stepsize.
!     R   TMAX            Maximum stepsize.
!     R   THETA           Correction parameter for stepsize.
!     R   SMALL           The smallest positive number such that
!                           1.0 + SMALL > 1.0.
!
!
!
!     * Subprograms used *
!
!     S   AGBFGS          Simplified subgradient aggregation.
!     S   AGGSR1          Subgradient aggregation.
!     S   AGSKIP          Subgradient aggregation using BFGS update.
!     S   DLBFGS          Computing the search direction by limited
!                           memory BFGS update.
!     S   DLSKIP          Skipping the updates and computing the search
!                           direction by limited memory BFGS update.
!     S   DLSR1           Computing the search direction by limited
!                           memory SR1 update.
!     S   DOBUN           Bundle selection.
!     S   LLS             Line search using function values and
!                           derivatives.
!     S   RESTAR          Initialization.
!     S   TINIT           Calculation of initial step size.
!     S   COPY            Copying of a vector.
!     S   GETIME          Execution time.
!     S   XDIFFY          Difference of two vectors.
!     S   RPRINT          Printout the results.
!     S   WPRINT          Printout the error and warning messages.
!     RF  EPS0            The smallest positive number such that
!                           1.0 + EPS0 > 1.0.
!     RF  VDOT            Dot product of two vectors.
!
!
!     * EXTERNAL SUBROUTINES *
!
!     SE  FUNDER          Computation of the value and the subgradient of
!                         the objective function. Calling sequence:
!                         CALL FUNDER(N,X,F,G,ITERM), where N is a number of
!                         variables, X(N) is a vector of variables, F is
!                         the value of the objective function, G(N) is
!                         the subgradient of the objective function, and
!                         ITERM is the error indicator.
!
!
!
!     Napsu Karmitsa (2002 - 2004, last modified 2007)
!
!

      subroutine LMBM(n,na,mc,mcu,x,xo,s,g,gp,ga,u,d,f,ax,ag,af,sm,um,&
           rm,umtum,c,smtgp,umtgp,tmpmc1,tmpmc2,tmpmc3,tmpmc4,tmpmc5,&
           tmpmc6,tmpn1,tmpn2,tmpmat,tolf,tolf2,tolb,tolg,tolg2,eta,&
           epsl,xmax,mit,mfe,mos,mtesf,iprint,method,iscale,nit,nfe,&
           iterm,time,rtim,funder_ptr)


!     Scalar Arguments
      integer n,na,mc,mcu,mit,mfe,mos,mtesf,iprint,nit,nfe,iterm,method,&
              iscale
      double precision f,eta,epsl,tolf,tolf2,tolb,tolg,tolg2,xmax

!     Array Arguments
      double precision x(*),xo(*),s(*),g(*),gp(*),ga(*),u(*),d(*),&
            ax(*),ag(*),af(*),sm(*),um(*),rm(*),umtum(*),c(*),&
            smtgp(*),umtgp(*),tmpmc1(*),tmpmc2(*),tmpmc3(*),tmpmc4(*),&
            tmpmc5(*),tmpmc6(*),tmpn1(*),tmpn2(*),tmpmat(*)

!     Local Scalars
      integer i,inew,ibfgs,isr1,iters,mal,mcc,mcinit,nnk,ntesf,nres,&
            ncres,ic,icn,nress,neps,iflag,ibun,nout
      double precision alfn,alfv,epsr,dnorm,gnorm,xnorm,p,tmax,t,&
            fo,gamma,pxnorm,theta,small

      real(8) :: prod, fold, told, calpha, predictedf, dpx, dpy

      procedure (funder_func), pointer :: funder_ptr

!     External Functions
!      DOUBLE PRECISION VDOT,EPS0
!      EXTERNAL VDOT,EPS0

!     External Subroutines
!      EXTERNAL FUNDER,COPY,XDIFFY,DLBFGS,DLSKIP,DLSR1,&
!            LLS,AGBFGS,AGGSR1,AGSKIP,DOBUN,TINIT,RESTAR,COPY2,&
!            RPRINT,WPRINT,GETIME

!     Intrinsic Functions
      intrinsic ABS,MAX,SQRT

!     Computational Time
      real time,strtim,ctim,rtim(2)

!     Parameters
      integer maxeps,maxnrs
      double precision eta9,fmin,tmin,lengthd,rho
      parameter(&
            maxeps = 20,&
            maxnrs = 2000,&
            eta9 = 1.0D+60,&
            fmin = -1.0D+60,&
            tmin = 1.0D-12,&
            lengthd = 1.0D+20,&
            rho = 1.0D-12)



      if (iprint .gt. 3) then
         if (method .eq. 0) write (6,fmt='(1X,''Entry to LMBM:'')')
         if (method .eq. 1) write (6,fmt='(1X,''Entry to LBB:'')')
      end if


!
!     Initialization
!

      nout = 0
      nit = 0
      nfe = 0
      ntesf = 0
      nres = 1
      ncres = -1
      nress = 0
      neps = 0
      iterm = 0
      iters = 1
      nnk = 0
      isr1 = 0
      alfn = 0.0D+00
      alfv = 0.0D+00
      mcinit=mc

      small = eps0()
      strtim = RTIM(1)

      if (tolf  .le. 0.0D+00) tolf = 1.0D-8
      if (tolf2 .eq. 0.0D+00) tolf2 = 1.0D+04
      if (tolb  .eq. 0.0D+00) tolb = fmin + small
      if (tolg  .le. 0.0D+00) tolg = 1.0D-06
      if (tolg2 .le. 0.0D+00) tolg2 = tolg
      if (xmax  .le. 0.0D+00) xmax = 1.5D+00
      if (eta   .lt. 0.0D+00) eta = 0.50D+00
      if (epsl  .le. 0.0D+00) epsl = 1.0D-04
      if (mos   .le. 0) mos = 2
      if (mtesf .le. 0) mtesf = 10
      if (mit   .le. 0) mit = 10000
      if (mfe   .le. 0) mfe = 20000

      tmax = xmax
      xnorm = eta9

      epsr = 0.25D+00+small
      if (2.0D+00*epsl .ge. epsr) then
         epsr = 2.0D+00*epsl + small
         if (epsr .ge. 0.5D+00) then
            call WPRINT(iterm,iprint,-2)
         end if
      end if


!
!     Computation of the value and the subgradient of the objective
!     function and the search direction for the first iteration
!

      call FUNDER_ptr(n,x,f,g,iterm)
      nfe = nfe + 1

      t = min(1.d0,TMAX)

      if (iterm .ne. 0) goto 900

      call RESTAR(n,mc,mcc,mcinit,inew,ibun,ibfgs,iters,gp,g,nnk,&
            alfv,alfn,gamma,d,ic,icn,mal,ncres,iflag)
            
      t = min(1.d0,TMAX)

      call DOBUN(n,na,mal,x,g,f,ax,ag,af,iters,ibun)

      goto 200


!
!     Start of the iteration
!

 100  continue


!
!     Serious step initialization
!

      if (iters.gt.0) then
         icn = 0
         alfn = 0.0D+00
         alfv = 0.0D+00
      end if


!
!     Direction finding
!

      if (iters.gt.0) then


!
!     BFGS update and direction determination
!

         call DLBFGS(n,mc,mcc,inew,ibfgs,iflag,d,g,gp,s,u,sm,um,rm,&
               umtum,c,smtgp,umtgp,gamma,tmpmc1,tmpmc2,tmpmc3,&
               tmpmc4,tmpn1,small,method,iscale)

      else
         if (method .eq. 0) then

!
!     SR1 update and direction determination
!

            call DLSR1(n,mc,mcc,inew,isr1,iflag,d,gp,ga,s,u,sm,um,rm,&
                  umtum,c,smtgp,umtgp,gamma,tmpmc1,tmpmc2,tmpmc3,tmpmc4,&
                  tmpmc5,tmpmc6,tmpn1,tmpn2,tmpmat,nnk,small,iprint)
            ibfgs=0
         else


!
!     BFGS skipping and direction determination
!

            call DLSKIP(n,mc,mcc,inew,ibfgs,iflag,d,ga,sm,um,rm,&
                  umtum,c,tmpmc1,tmpmc2,gamma,tmpmc3,tmpmc4,tmpmc5,&
                  tmpn1,iscale)

         end if
      end if


 200  continue


!
!     Computational time
!

      if (time .gt. 0.0e+00) then
         call GETIME(ctim,rtim)
         if (ctim-strtim .gt. time) then
            iterm = 6
            goto 900
         end if
      end if


!
!     Computation of norms
!

      if (iters .gt. 0) then
         gnorm = VDOT(n,g,g)
         dnorm = SQRT(VDOT(n,d,d))

         p = VDOT(n,g,d)

      else
         gnorm = VDOT(n,ga,ga)
         dnorm = SQRT(VDOT(n,d,d))

         p = VDOT(n,ga,d)
      end if


!
!     Test on descent direction
!

      if (p+small*SQRT(gnorm)*dnorm .le. 0.0D+00) then
         nres = 0

      else
         nres = nres + 1
         if (nres .eq. 1) then
            call WPRINT(iterm,iprint,-3)

            call RESTAR(n,mc,mcc,mcinit,inew,ibun,ibfgs,iters,gp,g,nnk,&
                  alfv,alfn,gamma,d,ic,icn,mal,ncres,iflag)
             
            t = min(1.d0,TMAX)
             
            if (ncres .gt. maxnrs) then
               nout = maxnrs
               iterm = -2
               go to 900
            end if

            call DOBUN(n,na,mal,x,g,f,ax,ag,af,iters,ibun)

            goto 200
         end if
         nout = -1
         iterm = -1
         goto 900
      end if


!
!     Stopping criterion
!

      nit = nit + 1
      pxnorm = xnorm
      xnorm = -p + 2.0D+00*alfv


!
!     Tests for termination
!

      if (xnorm .le. 1.0D+03*tolg .and.&
            (mcc .gt. 0 .or. ibfgs .eq. 2)) then

         if(0.5D+00*gnorm + alfv .le. tolg2 .and.&
               xnorm .le. tolg) then

            iterm = 1
            goto 900
         end if

         if (mc .lt. mcu .and. iflag .eq. 0) then
            mc=mc+1
            iflag=1
         end if
      end if


      if (nfe.ge.mfe) then
         nout = mfe
         iterm = 4
         goto 900
      end if


      if (nit.ge.mit) then
         nout = mit
         iterm = 5
         goto 900
      end if


      if (f.le.tolb) then
         iterm = 7
         goto 900
      end if


      if (iters .eq. 0) then
         if (ABS(xnorm - pxnorm) .le. small) then
            neps = neps + 1

            if (neps .gt. maxeps) then
               iterm = -4
               goto 900
            end if

         else
            neps = 0
         end if

      else
         neps = 0
      end if


!
!     Correction
!

      if (-p .lt. rho*gnorm .or. icn .eq. 1) then

         xnorm =xnorm + rho*gnorm
         dnorm=SQRT(dnorm*dnorm-2*rho*p+rho*rho*gnorm)

         if (iters .gt. 0) then
            do 230 i=1,n
               d(i)=D(i)-rho*G(i)
 230        continue

         else
            do 240 i=1,n
               d(i)=D(i)-rho*GA(i)
 240        continue
            icn = 1
         end if

         ic=1

      else
         ic=0
      end if


      if (pxnorm .lt. xnorm .and. nnk .gt. 2) then
         call WPRINT(iterm,iprint,-4)
      end if


      call RPRINT(n,nit,nfe,x,f,xnorm,0.5D+00*gnorm+alfv,iterm,iprint)


!
!     Preparation of line search
!

      fo = f

      if (iters .gt. 0) then
         call COPY2(n,x,xo,g,gp)
      end if

      if (dnorm.gt.0.0D+00) tmax = xmax/dnorm

      if (tmax .gt. tmin) then
         nress = 0

      else
         nress = nress + 1
         if (nress .eq. 1) then
            call WPRINT(iterm,iprint,-5)

            call RESTAR(n,mc,mcc,mcinit,inew,ibun,ibfgs,iters,gp,g,nnk,&
                  alfv,alfn,gamma,d,ic,icn,mal,ncres,iflag)
            
            t = min(1.d0,TMAX)

            if (ncres .gt. maxnrs) then
               nout = maxnrs
               iterm = -2
               go to 900
            end if

            call DOBUN(n,na,mal,x,g,f,ax,ag,af,iters,ibun)

            goto 200
         end if
         iterm = -1
         goto 900
      end if


!
!     Initial step size
!
      told = t
      t = min(1.d0,tmax)

!          print *,'mod iteration: selecting t:',t,tmax,tmin
    
      call TINIT(n,na,mal,x,af,ag,ax,ibun,d,f,p,t,tmax,tmin,&
            eta,eta9,mos,iters)
    
!      if (mod(nit,2) /= 0 .and. predictedf < f) then
!        t = told
!      else
!        print *,'mod iteration: selected t:',t,told,tmax,tmin      
!      end if

!
!     Line search with directional derivatives which allows null steps
!
      theta=1.0D+00
      if (dnorm .gt. lengthd) then
         theta=lengthd/dnorm
      end if

      call qdotdd( g(1:n),d(1:n),n,dpx,dpy )
      prod = dpx + dpy
      fold = f
          
      call LLS(n,x,g,d,xo,t,fo,f,p,alfn,tmin,&
            dnorm,xnorm,theta,epsl,epsr,eta,mos,iters,nfe,nnk,iterm,funder_ptr)
      
      print *,'Found t:',t,f,predictedf
      
      calpha  = (t*prod  + fold - f)/(t*t)

      t = min(abs(t*t*prod/(2.d0*(t*prod + fold - f))),tmax)
      !t = abs(t*t*prod/(f - (fold + t*prod)))

      predictedf = fold + t*prod - t*t*calpha
      
      print *,'Next time I will try:',t,predictedf

      ! C = J(x+d) - J(x) - prod
      ! predictedf = fold + t*prod + prod  + fold - f
                
      ! \frac{J(x + \alpha h) - J(x)}{\alpha h^T grad}

!      if (t .gt. 1d-6 .and. abs(prod) .gt. 1d-10) then

          !t = max(min(abs(t*t*prod/(2.d0*(t*prod  + fold - f))),tmax),1d-6)
          !t = min(abs(t*t*prod/(2*(t*prod  + fold - f))),tmax)
                    
!          if (t < 0.25) then
!            t = 2.0*t
!          end if
!      else
!          t = min(1.d0,TMAX)
!      end if

      if (iterm .ne. 0) goto 900

      if (tolf2 .ge. 0) then
         if (ABS(fo-f) .le. tolf2*small*MAX(ABS(f),ABS(fo),1.0D+00)&
               .and. iters .eq. 1) then

            iterm = 3
            goto 900

         end if
      end if

      if (ABS(fo-f) .le. tolf) then
         ntesf = ntesf + 1

         if (ntesf .ge. mtesf .and. iters .eq. 1) then
            iterm = 2
            goto 900
         end if

      else
         ntesf = 0
      end if


!
!     Bundle updating
!

      call DOBUN(n,na,mal,x,g,f,ax,ag,af,iters,ibun)


!
!     Computation of variables difference
!

      call XDIFFY(n,x,xo,s)


!
!     Computation of aggregate values and gradients difference
!

      if (iters.eq.0) then
         nnk = nnk + 1

         if (nnk.eq.1) then
            call COPY(n,gp,tmpn1)
            call XDIFFY(n,g,gp,u)
            call AGBFGS(n,mc,mcc,inew,ibfgs,iflag,g,gp,ga,u,d,sm,um,&
                  rm,c,umtum,alfn,alfv,gamma,tmpmc1,tmpmc2,ic,rho)

         else
            if (method .eq. 0) then
               call COPY(n,ga,tmpn1)
               call AGGSR1(n,mc,mcc,inew,iflag,g,gp,ga,d,alfn,alfv&
                     ,tmpmat,umtum,rm,gamma,smtgp,umtgp,tmpmc1,tmpmc2,sm&
                     ,um,tmpmc3,tmpmc4,tmpn2,x,u,icn,rho,small)
               call XDIFFY(n,g,gp,u)
            else
               call COPY(n,ga,tmpn1)
               call XDIFFY(n,g,gp,u)
               call AGSKIP(n,mc,mcc,inew,iflag,g,gp,ga,d,u,alfn,alfv&
                     ,umtum,rm,c,gamma,smtgp,umtgp,tmpmc1,tmpmc2,sm&
                     ,um,tmpmc3,tmpmc4,tmpn2,icn,rho,small)
            end if
         end if

         call COPY(n,xo,x)
         f = fo

      else
         if (nnk .ne. 0) then
            call COPY(n,ga,tmpn1)
         else
            call COPY(n,gp,tmpn1)
         end if
         nnk = 0
         call XDIFFY(n,g,gp,u)
      end if

      goto 100


 900  continue


!
!     Printout the final results
!

      if (iprint .gt. 3) then
         if (method .eq. 0) write (6,fmt='(1X,''Exit from LMBM:'')')
         if (method .eq. 1) write (6,fmt='(1X,''Exit from LBB:'')')
      end if
      call WPRINT(iterm,iprint,nout)
      call RPRINT(n,nit,nfe,x,f,xnorm,0.5D+00*gnorm+alfv,iterm,iprint)

      return
      end subroutine

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
